Poznámka:
l^2 - znamená, že 2 je horní index znaku l
l_1 - znamená, že 1 je dolní index znau l
v .md to chci mít správně zapsáno, takto je to jen z důvodu aktuálního zápisu do .txt formátu

Zadání úlohy:

Cílem úkolu je implementace paralelního řešení problému rozložení zařízení (Single-Row Facility Layout Problem, SRFLP).

Popis problému. SRFLP spočívá v hledání lineárního uspořádání sady zařízení, které bude minimalizovat (vážený) součet vzdáleností mezi každými dvěma zařízeními. Jako ilustraci si můžeme představit robotické rameno, které odebírá výrobky ze čtyř míst (např. pásů), jak je ukázáno na obr. 1. Každý pás ale dodává výrobky s různou intenzitou. Pokud by byly pásy na kterých se výrobky objevují často umístěny daleko od sebe (na obrázku např. m1, m4), bude využití robota neefektivní (bude se často přesunovat po dlouhé dráze mezi m1 a m4). Navíc šířka pásů může být různá.
Obrázek 1: příklad SRFLP
(srflp-2.png file)

Matematicky lze základní verzi SRFLP formulovat následujícím způsobem: mějme množinu zařízení, F = {1,2,....n}
se známou šířkou, L = (l_1, l_2,...,l_n). Dále mějme matici C = {c_ij} ∈ R^n.n s váhami přechodů mezi zařízením i a j. 
Tu si můžeme představit jako odhad pravděpodobnosti, že rameno bude z pozice i přecházet na pozici j.

Cílem řešení SRFLP je najít lineární uspořádání (=permutaci) zařízení, π = (π_1, π_2,...π_n)
, která bude minimalizovat násedující cenovou funkci:
(raw markdown v tex notaci:)
$$
\min_{\pi \in S_n} f_{\text{SRFLP}}(\pi),
$$

$$
f_{\text{SRFLP}}(\pi) = \sum_{1 \le i < j \le n} \left[ c_{\pi_i \pi_j} \cdot d(\pi_i, \pi_j) \right],
$$

$$
d(\pi_i, \pi_j) = \frac{l_{\pi_i} + l_{\pi_j}}{2} + \sum_{i < k < j} l_{\pi_k}.
$$


Konkrétní problém, který chceme řešit (instanci SRFLP) lze popsat např. takto:

Obrázek 2: příklad instance SRFLP

10
1 1 1 1 1 1 1 1 1 1
0 30 17 11 24 25 24 17 16 22
0 0 21 23 26 24 27 19 11 32
0 0 0 24 18 23 31 36 28 19
0 0 0 0 19 18 33 25 20 28
0 0 0 0 0 15 37 27 17 16
0 0 0 0 0 0 27 23 29 24
0 0 0 0 0 0 0 27 31 24
0 0 0 0 0 0 0 0 14 18
0 0 0 0 0 0 0 0 0 24
0 0 0 0 0 0 0 0 0 0

Význam řádků na obr. 2 je následující: řádek (1) obsahuje dimenzi problému, t.j. počet zařízení (n). Řádek (2) obsahuje šířky zařízení, l_1, l_2, ...,l_n. 
V případě této instance mají všechna zařízení shodnou šířku 1. řádky (3) - (12) pak obsahují matici C, tj. váhy přechodů mezi zařízeními, c_ij. 
Dolní část matice je naplněna nulami, vzhledem k tomu, že je problém symetrický, c_ij = c_ji
, představme si tam stejné hodnoty jako nad hlavní diagonálou. Na základě toho všecho tedy můžeme zformulovat následující zadání prvního úkolu.

Zadání. Vypracujte paralelní řešení SRFLP (instance Y-10_t.txt) pomocí metody Branch and Bound (stačí backtracking) se sdílením nejlepšího dosud nalezeného řešení.

Doporučení: Při řešení vycházejte z příkladu TSP. Problém je analogický (ale ne totožný).

Reference: Kothari, R., Ghosh, D. The single row facility layout problem: state of the art. OPSEARCH 49, 442–462 (2012). https://doi.org/10.1007/s12597-012-0091-4





Nápovědy:
PS: matice je vyplněná nad diagonálou - takže si to buď přehodit, nebo na to pamatovat
BEST: 5596 (očekávaný výsledek)

první suma - dva cykly - jeden vnořený (
    for i in range (n):
        for j in range (i+1, n + 1)
            d = calc_d(p,L,i,j)
            suma += C[....] * d
)

druhá suma (druhý vzorec) - jeden cyklus (
    for k in range(i, j+1):
        suma += L[p[k]]
)

load_data funkce v pythonu:

def load_data():
    path = "Y-10_T.txt"
    with open(path) as f:
        lines = f.readlines()
        number_of_items = int(lines[0])
        widths = lines[1]
        widths = [int(x) for x in widths.split()]
        tmp = lines[2:(2+number_of_items)]
        data = []
        for line in tmp:
            row = []
            parts = line.split()
            for part in parts:
                row.append(float(part))
            data.append(row)
    n = len(data)
    for i in range(n)
        for j in range(i + 1, n):
            data[j][i] = data[i][j]
    return [widths, data]